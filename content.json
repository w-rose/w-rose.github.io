[{"title":"jsonp如何实现跨域","date":"2017-02-28T12:17:38.000Z","path":"2017/02/28/jsonp/","text":"如果你能理解以下代码的执行结果，那么理解jsonp实现的跨域原理就是小菜一碟！12//test.jsfoo(123); 123456&lt;script&gt; function foo(data) &#123; console.log(data) &#125;&lt;/script&gt;&lt;script src=\"test.js\"&gt;&lt;/script&gt; 以上代码会在控制台上打印123。其实jsonp实现跨域的原理就这么简单，利用script标签可以实现跨域的特性，你需要做的只有以下两件事（1） 在全局定义一个函数foo（2） 和服务器约定好返回的字符串是&quot;foo()&quot;如何和服务器进行约定呢？你的函数名可以随便定义，但是服务器代码总不能跟着你的函数名变化而变化，所以需要借助http协议告知服务器你的函数名，我们可以用查询字符串携带信息给服务器，一般我们会用callback来携带函数名。这样你的script标签的src就类似下面这样1&lt;script src=\"http://......?callback=foo\"&gt;&lt;/script&gt; 服务器就可以通过查询字符串中callback键取到函数名，返回字符串callback + &quot;(123)&quot;这样我们在foo里面想怎么使用data就都可以实现啦！","tags":[{"name":"jsonp 跨域","slug":"jsonp-跨域","permalink":"http://yoursite.com/tags/jsonp-跨域/"}]},{"title":"实现jQuery的核心结构","date":"2017-02-24T09:25:20.000Z","path":"2017/02/24/jQuery/","text":"如果你是一个入门的前端工程师，那么你肯定知道jQuery，jQuery极大地方便了DOM操作，我们觉得它很强大，其实你自己可以实现这样的一个框架，这里我整理了一下自己的思路。 如何更快地获取DOM元素获取元素的方法很多，document.getElementById(id)、document.getElementsByTagName(tagname)、document.getElementsByClassName(classname)等等。用原生的API获取元素无疑是很麻烦的，每获取一个元素需要写一长串，甚至还定位不到自己想要的那个元素。html5中获取元素的APIdocument.querySelector(selector)、document.querySelectorAll(selector)，虽然我们可以通过C3选择器更便捷地定位到目标元素，但是写起来还是很麻烦。这时候，想到了封装函数123function getEle(selector) &#123; return document.querySelectorAll(selector);&#125; 这里返回的是一个NodeList结构的伪数组，如果是真数组，那我们操作起来不是更方便吗？于是改进我们的函数1234function getEle(selector) &#123; return Array.prototype.slice.call(document.querySelectorAll(selector));&#125;//借用函数的call和apply方法将伪数组转化成真数组的技能一定要get 这样，既可以快速得获取元素，同时又可以用到数组的方法，我们可以这样来使用getEle(&quot;div&quot;).forEach(...)但是获取到的结果只能用到数组的方法，远远不够，我们还想让它有操作dom、修改样式等等方法。每一个返回的对象都拥有同样的方法，这个时候想到了构造函数。 init构造函数通过构造函数创建出来的对象可以访问构造函数原型上的成员。123var init = function(selector) &#123; Array.push.apply(this, document.querySelectorAll(selector));&#125; 这样我们通过给init.prototype添加成员，返回的对象都可以访问到。问题又来了，难道每次获取元素都要用new init(selector)吗？你能想到什么办法去解决这个问题吗？ jQuery($)包装函数使用一个写法便捷的函数执行new init(selector)并暴露给用户，于是就有了以下代码12345678910(function (window) &#123; var init = function (selector) &#123; Array.push.apply(this, document.querySelectorAll(selector)); &#125; init.prototype = &#123;...&#125; var jQuery = function (selector) &#123; return new init(selector); &#125; window.jQuery = window.$ = jQuery;&#125;)(window); 这样初步雏形就有了，你一直以为你用的是jQuery对象，但其实init构造函数才是功臣。但是又出现了问题，如何去给jQuery对象拓展方法？要拓展方法必定是要在其原型上添加，但构造函数并没有暴露，你能想到什么方法吗？ 将构造函数挂载在jQuery的原型上","tags":[{"name":"jQuery代码分析","slug":"jQuery代码分析","permalink":"http://yoursite.com/tags/jQuery代码分析/"}]},{"title":"Hello World","date":"2017-02-07T01:58:59.437Z","path":"2017/02/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]